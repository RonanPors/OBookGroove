type User {

  # Le '!' ne signifi pas qu'il est obligatoire de récupérer l'id
  #  ça signifi que l'id récupéré doit forcément être du bon type et non pas null
  id: Int!
  pseudo: String
  email: String
  # Pourquoi String pour lastLogin ?
  # Le resolver va transformer le timestamptz en une belle date
  lastLogin: String
  isActive: Boolean
  refreshToken: String
  resetToken: String
  confirmToken: String
  phoneNumber: String
  profilePicture: String

  # QUESTION ? Est-il possible de juste mettre Book à la place de UserHasBook
  # Impossible, car books va récupérer seulement les accosiations
  # Il faut donc un type intermédiaire pour récupérer les livres en fonction des données de ces associations
  # books: [UserHasBook]!
  books: [Book]!

}

type UserSubList {

  # Il faut forcément que l'objet items contienne un tableau avec au moins un objet User
  items: [User!]!

  # Il faut forcément que totalCount ne soit pas null
  totalCount: Int!

}

input UpdateUserInput {

  id: Int!
  pseudo: String
  email: String
  phoneNumber: String
  profilePicture: String

}